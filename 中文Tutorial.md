# 字符串相关问题与算法 #
----
## 目录 ##
 1. 前言————一些啰嗦的话
 2. **一种用于字符串集合的数据结构————Trie树**
 3. 循环同构问题————最小表示法
 4. 最大回文串问题————Manacher算法
 5. 模式匹配问题————自动机家族
     * 从有向图到自动机
     * **单模板串匹配问题————KMP算法**
     * 多模板串匹配问题————AC自动机
     * 后缀匹配问题————后缀自动机(*)
     * 回文匹配问题————回文自动机(*)
 6. **后缀的最长公共前缀问题————后缀数组**

## 前言 ##

　　大概6月中旬的时候，本弱接到尹榛菲通知，暑假要讲课，从搜索、数据结构、DP、图论、数学、字符串六个专题里选出一个专题负责。在这些专题当中：
图论内容太多，网络流、二分图、强连通分量、拓扑排序一类的深坑基本上不会，这方面必然是带不动诸位假学生，真·大佬；数学内容太深，且不论我懵懵懂懂的包括容斥原理、polya原理在内的组合数学，即使是数论同余那些概念，FFT的作用与实现还够我喝上一壶；DP就不说了，各种被廖神秒杀……

　　于是挑了个软柿子捏，有了这篇字符串的博客。

（以上是废话）

 ![](images\scan-of-algorithms.png)

　　虽然说字符串问题相对来说思维强度和技巧性要求较低，但能把上面这么多内容都学习到位，也并不是一件容易的事情。目录中，加粗的三个内容是字符串问题最精华、最实用、竞赛考的最多，同时也是最灵活的三个问题。**Trie树**的出题非常灵活，**KMP**作为模板串匹配问题的经典算法被收录在CLRS中，**后缀数组**则是处理单个字符串信息强有力的工具连续在区域赛中出现。它们的重要性不言而喻。请读者优先学习这三方面的内容。

　　本篇教程**以问题为导向**，每个典型问题为一个学习单元。每个学习单元首先会系统性地介绍字符串的有关概念，讲解字符串的重点问题，之后会是它们的解决算法。在此之后，还有对各大算法的正确性证明与复杂性分析。在这篇教程中，每个学习单元将由下列四个部分组成：

 * 问题描述
 * 算法过程及实现
 * 正确性证明与复杂度分析
 * 参考文献

　　你能在问题描述中知晓该问题的背景知识和相关概念；在算法过程中了解各个算法的具体步骤，并有机会亲身实践它；如果你对教程中内容有所疑问，可以看看参考文献，看看笔者引用的资料是怎么写的。

　　最后要说一句，这是本人第一次写教程，水平有限，在教程中难免出现写的不清楚或是有纰漏的地方。如有问题或疑问，请不要犹豫，直接与我交流。

## 一种用于字符串集合的数据结构————Trie树 ##

### 问题描述 ###

　　在处理复数个字符串时，对字符串进行排序往往是一个行之有效的操作。字符串的字典序，对于字符串,先按首字符排序,如果首字符相同,再按第二个字符排序,以此类推。如：

    atcoder
    best
    bestcoder
    cf
    codeforces
    regional
    topcoder
就是字符串的一个递增序列。

**问题1**

　　小明有一本字典。现在，小明想要知道自己前两天背诵过的若干个单词有没有记错，他需要背出脑海里的每一个单词，然后在字典中查找该单词是否存在。

　　已知字典共有n个单词（字典本身无序），每个单词长度不超过L。小明给出k个“单词”，对于每一个单词，你需要判断它是否在字典中存在。

**分析**

　　最朴素的办法是对每个“单词”，遍历整个字典，再比较单词与字典中每个词是否相同。时间复杂度为O(nmL)。

　　聪明一点的办法为：对字典进行排序，再利用二分搜索查询每个单词：

    std::sort(dict, dict+n);//对字典排序，字典本身为一个容量为n的string数组
    if(std::binary_search(dict, dict+n, word) )//查找某个单词
        std::cout<<"Yes, it is a word!"<<std::endl;
　　这是二分查找的经典姿势。普通的二分查找时间单词时间复杂度为O(log n)。但在字符串中，由于每次比较是O(m)的，每次二分查找的时间变为O( L×log n )。相应的，整个算法的时间复杂度变为了O( (n+k)×L×log n )。

　　虽然说相对于朴素算法，这个算法对时间复杂度有了非常大的改善。但我们将会看到，利用Trie树，我们能在更短的时间内完成上述问题:

**算法过程**

　　Trie树，又称字典树、单词查找树、前缀树，是一种树形结构。字典树的基本思想是缩点。例如，对于有序序列：

    ok
    okay
    prefix
    pretend

　　字典树将每个单词看做一个由单词中字母组成的链表。对于单词与单词中公共的节点部分，将它们缩成同一个节点：

![](images\Trie.png)
注：图中“^"表示字符串开头，"$"表示字符串结尾。

　　通过这种方法，Trie树将相同的前缀“聚合”起来，后面将会看到，这种聚合能提高查找的效率。

　　可以看出，Trie是一颗**多叉树**，当前节点的“度数”取决于具有当前公共前缀的字符串集合的下一个字母种数。一颗Trie树中**节点的最大度数**等于**字符串字符集的大小**（如：不区分大小写的英语单词，它的字符集为26，表示a-z的26个字符）实际操作时，通常使用一个长度等于最大值的定长数组维护这种多叉关系，并用null表示该分支不存在：

    class Trienode{        //Trie树的节点类

    public:
        Trienode *next[26];//容量为26的节点儿子信息，可以用来维护字符集为英语26个小写字母的单词集合
        Trienode(){
            memset(next, null, sizeof(next) );//初始化时，节点的度数为0，next指针全部指向null
        }
        ...
    };
　　如此，Trie的每个节点无论其实际度数为何，占用空间都等于度数最大情况的空间消耗。这种操作造成一定程度上的空间浪费，但由于每个节点维护的是线性表，每个字符的查询时间为与字符集大小无关的常量，整个过程的时间复杂度较低，这一点将在紧接着的分析中得到体会。

　　一颗Trie树能完成下述三种操作（已知Trie树为dict，字符串为s）：

     * 查询操作：查询dict中是否存在s，或查询满足某些特定条件的字符串（如：与s哈夫曼距离最小的字符串si）
     * 插入操作：将字符串s插入dict中
     * 删除操作：将s从dict中删除

　　对于查询操作，每次取出字符串中的一个字符，调到当前节点对应字符的儿子节点，直到读到字符串末位，或对应的儿子节点不存在。该过程的时间复杂度为O(L)。

    bool search(Trienode *T, const char s[], size_t i)//T:指向Trie树当前节点的指针，s:查询的字符串，i:当前所处第几个字符
    {
        if(s[i]=='\0')//到达s的字符串尾部，表明成功找到了该字符串
            return true;
        if(T->next[s[i]-'a']==null)//当前节点不具有相应儿子节点，表明该字符串不存在
            return false;
        return search(T->next[s[i]-'a'], s, i+1);//继续查询
    }

　　对于插入操作，每次先查找dict中s的最长公共前缀，再将s的剩余部分插入到该节点之后。时间复杂度同样为O(L)。

    void insert(Trienode *T, const char s[], size_t i)//T:指向Trie树当前节点的指针，s:查询的字符串，i:当前所处第几个字符
    {
        if(s[i]=='\0')//到达s的字符串尾部，表明插入过程结束
            return;
        if(T->next[s[i]-'a']==null)//当前节点不具有相应儿子节点，表明需要创建新节点
            T->next[s[i]-'a'] = new Trienode;
        insert(T->next[s[i]-'a'], s, i+1);//前往下一个节点
    }


　　对于删除操作，先查找到s在Trie树中的叶子节点，再回溯删除节点，直到回溯的节点有其它分支，或到达根节点。时间复杂度同样为O(L)。


**参考文献**

[Trie树：应用于统计和排序](http://blog.csdn.net/hguisu/article/details/8131559)

---