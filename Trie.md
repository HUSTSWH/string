# 一种用于字符串集合的数据结构——Trie树 #

　　Trie树，又称字典树、单词查找树、前缀树，是一种树形数据结构。和我们所熟知的平衡树一样，Trie树储存元素的有序集合，并支持对元素的动态增、删、查功能。所不同的是，Trie树相比于以string为元素的平衡树时间复杂度更低，且由于Trie树的独特结构，能够解决一类与位相关的问题。

[TOC]

## 问题描述 ##

　　小明有一本字典。现在，小明想要知道自己前两天背诵过的若干个单词有没有记错，他需要背出脑海里的每一个单词，然后在字典中查找该单词是否存在。

　　已知字典共有n个单词（字典本身无序），保证单词只包含小写字母，每个单词长度不超过L。小明给出k个“单词”，对于每一个单词，你需要判断它是否在字典中存在。

**分析**

　　最朴素的办法是对每个“单词”，遍历整个字典，再比较单词与字典中每个词是否相同。时间复杂度为 $O(n \times k \times L)$ 。

　　在处理复数个字符串时，对字符串进行排序往往是一个行之有效的操作。字符串的字典序，对于字符串,先按首字符排序,如果首字符相同,再按第二个字符排序,以此类推。如：

    atcoder
    best
    bestcoder
    cf
    codeforces
    regional
    topcoder

就是字符串的一个递增序列。

　　因此，我们可以采用快速排序算法对字典进行排序，再利用二分搜索查询每个单词：
``` cpp
std::sort(dict, dict+n);//对字典排序，字典本身为一个容量为n的string数组
if(std::binary_search(dict, dict+n, word) )//查找某个单词
    std::cout<<"Yes, it is a word!"<<std::endl;
```
　　这是二分查找的经典姿势。普通的二分查找时间单词时间复杂度为$O(log\ n)$。但在字符串中，由于每次比较是$O(m)$的，每次二分查找的时间变为$O( L\times log\ n )$。相应的，整个算法的时间复杂度变为了$O( (n+k)\times L\times log\ n )$。

　　虽然说相对于朴素算法，这个算法对时间复杂度有了非常大的改善。但我们将会看到，利用Trie树，我们能在更短的时间内完成上述问题:

## 算法过程与实现 ##

　　字典树的基本思想是缩点。例如，对于有序序列：

    ok
    okay
    prefix
    pretend

　　字典树将每个单词看做一个由单词中字母组成的链表。对于单词与单词中公共的节点部分，将它们缩成同一个节点：

![](images/Trie.png)

注：图中“^"表示字符串开头，"$"表示字符串结尾。

　　通过这种方法，Trie树将相同的前缀“聚合”起来，后面将会看到，这种聚合能提高查找的效率。

　　可以看出，Trie是一颗**多叉树**，当前节点的“度数”取决于具有当前公共前缀的字符串集合的下一个字母种数。一颗Trie树中**节点的最大度数**等于**字符串字符集的大小**（如：不区分大小写的英语单词，它的字符集为26，表示a-z的26个字符）实际操作时，通常使用一个长度等于最大值的**定长数组**维护这种多叉关系，并用null表示该分支不存在：
```cpp
//Trie树的节点类
class Trienode{
    //儿子节点指针,使用定长数组，保证边的增加、访问、删除在O(1)时间内完成
    Trienode *next[26];
public:
    Trienode(){
        //初始化时，节点的度数为0，next指针全部赋空值
        memset(next, 0, sizeof(next) );
        ...
    }
};
```
　　如此，Trie的每个节点无论其实际度数为何，占用空间都等于度数最大情况的空间消耗。这种操作造成一定程度上的空间浪费，但由于每个节点维护的是线性表，每个字符的查询时间为与字符集大小无关的常量，整个过程的时间复杂度较低，这一点将在紧接着的分析中得到体会。

　　一颗Trie树能完成下述三种操作（已知Trie树为dict，字符串为s）：

 * 查询操作：查询dict中是否存在s。若经过修改，Trie树可查询满足某些特定条件的字符串（如：与s哈夫曼距离最小的字符串si）
 * 动态插入：将字符串s插入dict中
 * 动态删除(*)：将字符串s从dict中删除

　　对于**查询操作**，每次取出字符串中的一个字符，调到当前节点对应字符的儿子节点，直到读到字符串末位，或对应的儿子节点不存在。
```cpp
//节点类的成员函数。s:查询的字符串，i:当前所处第几个字符
bool search(const char s[], size_t i = 0){
    //到达s的字符串尾部，表明成功找到了该字符串
    if(s[i]=='\0')
        return istail;

    //当前节点不具有相应儿子节点，表明该字符串不存在
    if(next[s[i]-'a'] == NULL)
        return false;

	//继续递归过程
    return next[s[i]-'a']->search(s, i+1);
}
```
　　对于**插入操作**，每次先查找dict中s的最长公共前缀，再将s的剩余部分插入到该节点之后。
```cpp
//s:查询的字符串，i:当前所处第几个字符
void insert(const char s[], size_t i = 0){
	//当前前缀的容量+1
    size++;

	//到达s的字符串尾部，表明插入过程结束
    if(s[i] == '\0'){
		//对节点的卫星数据赋值，表示该节点是一个字符串尾端
        istail = true;
        return;
    }

	//若相应儿子节点不存在，创建新的节点
    if(next[s[i]-'a'] == NULL)
        next[s[i]-'a'] = new Trienode;

    //继续递归过程
    next[s[i]-'a']->insert(s, i+1);
}
```
　　**删除操作**的实现需要借助额外的卫星数据。在每个节点上记录共有当前前缀的字符串数目size。首先，判断待删字符串s在Trie树中是否存在；然后，从叶子节点逐步往上回溯，并删除不再有效的节点。
```cpp
//s:查询的字符串，i:当前所处第几个字符
void erase(const char s[], size_t i = 0){
	//当前前缀容量-1
        size--;

    if(s[i]=='\0'){
        istail = false;
        return;
    }

	//先递归处理儿子
    next[s[i]-'a']->erase(s, i+1);

	//若儿子容量为0，删除该儿子，释放相应空间
    if(next[s[i]-'a']->size == 0){
        delete next[s[i]-'a'];
        next[s[i]-'a'] = NULL;
    }
}
```
　　至此，Trie树的全部基本功能已经全部讲解完毕。完整代码请看[基于递归与动态开辟内存的Trie树实现](sources/Trie.cpp)。注意，上述代码仅作理解用，实际过程中大量的动态内存操作与递归写法是非常费时的。为了避免这种结果，建议读者先读懂代码，再以迭代写法、手动开辟静态内存池并自行分配的方式重构。

## 正确性证明与复杂度分析 ##

　　从上面的分析，我们可以推知：对于查询、插入、删除中每个操作，利用Trie树处理时的时间复杂度为 $O(L)$ 。

　　要创建一个字典，只需依次将字符集的每个字符串插入Trie树，整个过程是 $O(n \times L)$ 的。注意到Trie树中各字符串是有序的，而建立Trie树的过程超越了快速排序算法的 $O(n \times L \times log\ n)$ 。这是由于Trie树采用了类似桶排序的方式，因而突破了基于比较的排序算法的下界。

　　接下来是对Trie树的空间消耗分析(*)。

  1. 由于Trie树每个节点需要存储大小等同于字符集大小的儿子指针，它的每个节点的空间消耗是相当大的。（如，对上例中的代码，每个节点存储$26$个指针，$1$个整形数，$1$个bool，其总空间为$112$字节）
  2. 可以推知，一般情况下重叠缩点的部分在Trie树中只占较小部分。对于给出的字符串集合，无论在最坏情况还是平均情况下Trie树所需的节点个数近似为 $n \times L$ 。

　　因此，Trie树总共的空间消耗约为：$n \times L \times (4\sigma+2)$字节。（例:对于示例中的Trie树，若$n \times L=1E6$，在32位机下该Trie的空间消耗为106MB）

## 相关文档 ##

 * [基于递归与动态开辟内存的Trie树实现](sources/Trie.cpp)
 * [Trie树：应用于统计和排序](http://blog.csdn.net/hguisu/article/details/8131559)

